def variantsList

def getValidXmlFiles(inputDirs){
    // get all xml files in value dir (buildtype|flavor|main)

    def set = [] as Set
    inputDirs.each{ inputDir ->
        def FileTree tree = fileTree(inputDir){
            include "layout**/**"
            include "menu**/**"
            include "xml**/**"
        }
        tree.matching{
            include '*.xml'
        }
        set.addAll(tree.getFiles())
    }

    def validXmlFiles = []
    set.each { f -> validXmlFiles << f.getName()}
    return validXmlFiles
}

def getStyleFiles(inputDirs){
        // get all xml files in value dir (buildtype|flavor|main)
    def set = [] as Set
    inputDirs.each{ inputDir ->
        def FileTree tree = fileTree(inputDir){
            include "values**/**"
        }
        tree.matching{
            include '*.xml'
        }
        set.addAll(tree.getFiles())
    }

    def styleFiles = []
    set.each { f -> styleFiles << f}
    return styleFiles
}

def getStyleStrings(node, includedXMLTags){
    def strings = [] as Set
    node.childNodes().each { child ->
        child.attributes().each{ attribute ->
            includedXMLTags.each { tag ->
            String androidTag = "android:" + tag
            if(attribute.getKey().equals("name") && attribute.getValue().equals(androidTag) && child.text().contains("@string/")){
                try{
                    strings << child.text()
                    } catch (Exception){

                    }
                }
            }
        }
       getStyleStrings(child, includedXMLTags).each{ strings << it }
    }
    return strings
}

//style xml differs from layout files
def replaceAtStringForStyle(node,includedXMLTags, string) {
    node.childNodes().each { child ->
        child.attributes().each{ attribute ->
            includedXMLTags.each { tag ->
                String androidTag = "android:" + tag
                if(attribute.getValue().equals(androidTag) && child.text().equals(string)){
                    try{
                            child.replaceBody(string.replace("@string/", "")) // replaceBody is from NodeChildren - groovy.util.slurpersupport
                        } catch (Exception e){
                    }
                }
            }
        }

        // recursive
        replaceAtStringForStyle(child, includedXMLTags, string)
    }

    return node
}

def replaceAtString(node,includedXMLTags) {
    node.childNodes().each { child ->

        child.attributes().each{ attribute ->
            includedXMLTags.each { tag ->
                String androidTag = "android:" + tag
                if(attribute.getKey().equals(androidTag) && attribute.getValue().contains("@string/")){
                    //println "TAG MATCH:"+attribute.getValue()
                    try{
                        child.attributes()[attribute.getKey()] = attribute.getValue().replace("@string/", "")
                        } catch (Exception){
                    }
                }
            }
        }

        // recursive
        replaceAtString(child, includedXMLTags)
    }

    return node
}


if(android.hasProperty("applicationVariants")) {
    variantsList = android.applicationVariants
} else if(android.hasProperty("libraryVariants")) {
    variantsList = android.libraryVariants
} else if(android.hasProperty("testVariants")) {
    variantsList = android.testVariants
}
 
variantsList.all { variant ->

    def buildVariant = variant.variantData.getVariantConfiguration().getFullName().capitalize();
    def buildType = variant.buildType.name

    def mainLayoutDir = "$projectDir/src/main/res"
    def buildLayoutDir = "$projectDir/src/$buildType/res"
    def flavorLayoutDir = ""

    def variantBuildDir = "$variant.mergeResources.outputDir"
    def bundleBuildDirBase = ""
    def bundleBuildDir = "" 

    def packageTaskName = "package"+buildVariant+"Resources"
    if(tasks.hasProperty(packageTaskName)){
        bundleBuildDirBase = tasks[packageTaskName].outputDir
        bundleBuildDir = "$bundleBuildDirBase"
    }

    def inputDirs = [ mainLayoutDir, buildLayoutDir ]
    def flavor = ""
    if(variant.variantData.getVariantConfiguration().hasFlavors()) {  
        flavor = variant.getVariantData().getVariantConfiguration().getFlavorName()
        flavorLayoutDir = "$projectDir/src/$flavor/res"
        inputDirs = [ mainLayoutDir, buildLayoutDir, flavorLayoutDir]
    }

    // get relevant xml files before merging
    def validXmlFiles = getValidXmlFiles(inputDirs)
    def styleFiles = getStyleFiles(inputDirs)

    //println validXmlFiles
    variant.outputs.each { output ->
        def includedXMLTags = ['text','hint','title','dialogTitle','summary','dialogMessage','negativeButtonText','positiveButtonText','summaryOff','summaryOn','switchTextOff','switchTextOn'/*,'contentDescription'*/]

        def taskNameMerge = "applangaMerge$buildVariant"
        final def task1 = task("$taskNameMerge"() << {
            description = 'Replaces String ID References with String ID values in all packaged Layout, Menu, Xml, Value files'
            
            // <!-- STYLE XML
            def FileTree variantBuildDirTreeStyles = fileTree(variantBuildDir){
                include 'values**/**/*.xml'
            }
            variantBuildDirTreeStyles.matching {
                include '*.xml'
            }

            def styleFilesBuildDir = [] as Set
            styleFilesBuildDir = variantBuildDirTreeStyles.getFiles()

            // get all strings which should be replaced
            def styleStringsToReplace = [] as Set
            styleFiles.each{ file -> 
                getStyleStrings(new XmlSlurper(false,false).parse(file.getAbsolutePath()), includedXMLTags).each{
                    styleStringsToReplace << it
                }
            }
                
            styleFilesBuildDir.each{ f ->
                def sXml = new XmlSlurper(false, false).parse(f)

                styleStringsToReplace.each{ s ->
                    replaceAtStringForStyle(sXml, includedXMLTags, s)
                }

                def sXmlFileString = groovy.xml.XmlUtil.serialize(sXml)
                f.delete()
                f.write(sXmlFileString, 'UTF-8') // style xml save to file
            }

            // STYLE XML -->

            def FileTree variantBuildDirTree = fileTree(variantBuildDir){
                include 'layout**/**/*.xml'
                include 'menu**/**/*.xml'
                include 'xml**/**/*.xml'
            }
            variantBuildDirTree.matching {
                include '*.xml'
            }

            def files = [] as Set
            files = variantBuildDirTree.getFiles()

            files.each { f ->
                def matching = false

                validXmlFiles.each { vf ->
                    if(vf.equals(f.getName())){
                        matching = true
                    }
                }

                if(matching){
                    def fXml = new XmlSlurper(false, false).parse(f)
                    fXml = replaceAtString(fXml, includedXMLTags)
                    
                    //println "modified file: " + f.getPath()
                    def xmlFileString = groovy.xml.XmlUtil.serialize(fXml)
                    f.delete()
                    f.write(xmlFileString, 'UTF-8')
                }
            }
        })

        def taskNameBundle = "applangaBundle$buildVariant"
        final def task2 = task("$taskNameBundle"() << {
            description = 'Replaces String ID References with String ID values in all packaged Layout, Menu, Xml, Value files'
            
            // <!-- STYLE XML
            def FileTree variantBuildDirTreeStyles = fileTree(variantBuildDir){
                include 'values**/**/*.xml'
            }
            variantBuildDirTreeStyles.matching {
                include '*.xml'
            }

            def styleFilesBuildDir = [] as Set
            styleFilesBuildDir = variantBuildDirTreeStyles.getFiles()

            // get all strings which should be replaced
            def styleStringsToReplace = [] as Set
            styleFiles.each{ file -> 
                getStyleStrings(new XmlSlurper(false,false).parse(file.getAbsolutePath()), includedXMLTags).each{
                    styleStringsToReplace << it
                }
            }
                
            styleFilesBuildDir.each{ f ->
                def sXml = new XmlSlurper(false, false).parse(f)

                styleStringsToReplace.each{ s ->
                    replaceAtStringForStyle(sXml, includedXMLTags, s)
                }

                def sXmlFileString = groovy.xml.XmlUtil.serialize(sXml)
                f.delete()
                f.write(sXmlFileString, 'UTF-8') // style xml save to file
            }

            // STYLE XML -->

            def FileTree variantBuildDirTree = fileTree(variantBuildDir){
                include 'layout**/**/*.xml'
                include 'menu**/**/*.xml'
                include 'xml**/**/*.xml'
            }
            variantBuildDirTree.matching {
                include '*.xml'
            }

            def files = [] as Set
            files = variantBuildDirTree.getFiles()

            files.each { f ->
                def matching = false

                validXmlFiles.each { vf ->
                    if(vf.equals(f.getName())){
                        matching = true
                    }
                }

                if(matching){
                    def fXml = new XmlSlurper(false, false).parse(f)
                    fXml = replaceAtString(fXml, includedXMLTags)
                    
                    //println "modified file: " + f.getPath()
                    def xmlFileString = groovy.xml.XmlUtil.serialize(fXml)
                    f.delete()
                    f.write(xmlFileString, 'UTF-8')
                }
            }
        })

        final def applangaParseIgnoredStrings = tasks.create(name: "applangaParseIgnoredStrings$buildVariant") << {
            def buildValues = new File("$variant.mergeResources.outputDir/values/values.xml")
            if(buildValues.exists()){
                def ignoredStringsFile = new File("$variant.mergeResources.outputDir/raw/applanga_ignore.strings");
                def ignoredStrings = "";
                def parsedValuesXml
                try{
                    // can fail on windows due to wrong xml encoding (windows-1252 instead of UTF-8)
                    parsedValuesXml = (new XmlParser()).parse(buildValues)
                } catch (Exception) {
                    groovy.util.CharsetToolkit toolkit = new CharsetToolkit(buildValues)
                    //logger.error toolkit.getCharset().displayName()
                    parsedValuesXml = (new XmlParser()).parseText(buildValues.getText(toolkit.getCharset().displayName()))
                }

                parsedValuesXml.children().each{ element ->
                    if(element.name() == "string" || element.name() == "string-array" ) {
                    //println element.@name
                    if(element.@translatable != null) {
                        println "translatable: "+ element.@translatable + " - Element: " + element.@name
                            if(element.@translatable == "false" || element.@translatable == false) {
                                //println "Name: " + element.name() + " String: " +  element.@name + ", translatable : " + element.@translatable
                                
                                def ignoreElement = element.@name
                                // if element contains "." we have to have two versions, the original and underscores instead of points
                                ignoreElement = ignoreElement.contains('.') ? ignoreElement.replaceAll('\\.','_') + "," + ignoreElement : ignoreElement;

                                ignoredStrings = ignoredStrings + ignoreElement + ","
                            }
                        }
                    }
                }

                def rawFolder = new File("$variant.mergeResources.outputDir/raw");
                if(!rawFolder.exists()) {
                    rawFolder.mkdir();
                }
                ignoredStringsFile.createNewFile();
                ignoredStringsFile.write(ignoredStrings, 'UTF-8')

                /*
                if(tasks.hasProperty(packageTaskName))
                {
                    def rawFolderPack = new File("$bundleBuildDirBase/raw");
                    if(rawFolderPack.exists()) {
                        def ignoredStringsFilePack = new File("$bundleBuildDirBase/raw/applanga_ignore.strings");
                        ignoredStringsFilePack.createNewFile();
                        ignoredStringsFilePack.write(ignoredStrings)
                    }
                }*/
            }
        }

        final def applangaParseAllowedStrings = tasks.create(name: "applangaParseAllowedStrings$buildVariant") << {
            def allowedStringsFile = new File("$variant.mergeResources.outputDir/raw/applanga_allow.strings");
            def allowedStrings = "";

            inputDirs.each { inputDir -> 
                def FileTree tree = fileTree(inputDir){
                    include "values**/**"
                }
                tree.matching{
                    include '*.xml'
                }

                tree.getFiles().each(){ f ->
                    def parsedValuesXml = (new XmlParser()).parse(f)
                    // parsedValuesXml instance of node
                    // parsedValuesXml.children() instance of list
                    parsedValuesXml.children().each { element ->
                    	// element instance of Node
                    	if(element instanceof groovy.util.Node){
	                        if(element.name() == "string" || element.name() == "string-array" ) {
	                            //println element.@name

                                def addToAllowedStrings = false

	                            if(element.@translatable != null) {
	                                //println "translatable: "+ element.@translatable + " - Element: " + element.@name
	                                if((element.@translatable == true) || (element.@translatable == "true")) {
	                                    //println "Name: " + element.name() + " String: " +  element.@name + ", translatable : " + element.@translatable
	                                    addToAllowedStrings = true
	                                }
	                            } else {
	                                //println "translatable: false - Element: " + element.@name
	                                addToAllowedStrings = true
	                            }
                                if(addToAllowedStrings){
                                    def allowedElement = element.@name
                                    //same as for ignored strings
                                    allowedElement = allowedElement.contains('.') ? allowedElement.replaceAll('\\.','_') + "," + allowedElement : allowedElement;

                                    allowedStrings = allowedStrings + allowedElement + ","
                                }
	                        }
	                    } else {
	                    	try {
	                    		logger.error "$element in file $f is not a Node. Please contact Applanga for support." // does that ever fail?
	                    	} catch(Exception){}
                            throw new GradleException("Please contact Applanga for support. Error in file: $f")
	                    }
                    }
                }
            }

            def rawFolder = new File("$variant.mergeResources.outputDir/raw");
            if(rawFolder.exists()) {
                allowedStringsFile.createNewFile();
                allowedStringsFile.write(allowedStrings, 'UTF-8')
            }
        }

        variant.mergeResources.finalizedBy(task1)

        if(tasks.hasProperty(packageTaskName))
        {
            tasks[packageTaskName].finalizedBy(task2)
        }

        task1.finalizedBy(applangaParseIgnoredStrings);

        //applangaParseIgnoredStrings.mustRunAfter task1
        output.processResources.dependsOn applangaParseIgnoredStrings
        //applangaParseIgnoredStrings.dependsOn applangaParseAllowedStrings
    }
}

repositories {
    maven { url 'https://raw.github.com/applanga/sdk-android/master/maven/releases/' }
}
