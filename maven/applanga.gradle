def variantsList


//path should not end with '/'!
//create path if does'nt exist
def createFileSafe(pathToFileDir, fileName){
    //logger.error "${pathToFileDir}/${fileName}"
    def fileDir = new File(pathToFileDir);
    if(!fileDir.exists()){
        fileDir.mkdirs();//mkdir != mkdirs (!)
    }
    def file = new File(pathToFileDir + "/" + fileName);
    file.createNewFile();
    return file;
}

def getValidXmlParser(File f){
    def result
    try{
        // can fail on windows due to wrong xml encoding (windows-1252 instead of UTF-8)
        result = (new XmlParser()).parse(f)
    } catch (Exception) {
        //guess encoding and parse again
        groovy.util.CharsetToolkit toolkit = new CharsetToolkit(f)
        logger.error "warning: $f is not proper UTF-8, indicate encoding!"
        result = (new XmlParser()).parseText(f.getText(toolkit.getCharset().displayName()))
    }
    return result
}

def getValidXmlFiles(inputDirs){
    // get all xml files in value dir (buildtype|flavor|main)

    def set = [] as Set
    inputDirs.each{ inputDir ->
        def FileTree tree = fileTree(inputDir){
            include "layout**/**"
            include "menu**/**"
            include "xml**/**"
        }
        tree.matching{
            include '*.xml'
        }
        set.addAll(tree.getFiles())
    }

    def validXmlFiles = []
    set.each { f -> validXmlFiles << f.getName()}
    return validXmlFiles
}

def getStyleFiles(inputDirs){
        // get all xml files in value dir (buildtype|flavor|main)
    def set = [] as Set
    inputDirs.each{ inputDir ->
        def FileTree tree = fileTree(inputDir){
            include "values**/**"
        }
        tree.matching{
            include '*.xml'
        }
        set.addAll(tree.getFiles())
    }

    def styleFiles = []
    set.each { f -> styleFiles << f}
    return styleFiles
}

def getStyleStrings(node, includedXMLTags){
    def strings = [] as Set
    node.childNodes().each { child ->
        child.attributes().each{ attribute ->
            includedXMLTags.each { tag ->
            String androidTag = "android:" + tag
            if(attribute.getKey().equals("name") && attribute.getValue().equals(androidTag) && child.text().contains("@string/")){
                try{
                    strings << child.text()
                    } catch (Exception){

                    }
                }
            }
        }
       getStyleStrings(child, includedXMLTags).each{ strings << it }
    }
    return strings
}

//style xml differs from layout files
def replaceAtStringForStyle(node,includedXMLTags, string) {
    node.childNodes().each { child ->
        child.attributes().each{ attribute ->
            includedXMLTags.each { tag ->
                String androidTag = "android:" + tag
                if(attribute.getValue().equals(androidTag) && child.text().equals(string)){
                    try{
                            child.replaceBody(string.replace("@string/", "")) // replaceBody is from NodeChildren - groovy.util.slurpersupport
                        } catch (Exception e){
                    }
                }
            }
        }

        // recursive
        replaceAtStringForStyle(child, includedXMLTags, string)
    }

    return node
}

def replaceAtString(node,includedXMLTags) {
    node.childNodes().each { child ->

        child.attributes().each{ attribute ->
            includedXMLTags.each { tag ->
                String androidTag = "android:" + tag
                if(attribute.getKey().equals(androidTag) && attribute.getValue().contains("@string/")){
                    //println "TAG MATCH:"+attribute.getValue()
                    try{
                        child.attributes()[attribute.getKey()] = attribute.getValue().replace("@string/", "")
                        } catch (Exception){
                    }
                }
            }
        }

        // recursive
        replaceAtString(child, includedXMLTags)
    }

    return node
}


if(android.hasProperty("applicationVariants")) {
    variantsList = android.applicationVariants
} else if(android.hasProperty("libraryVariants")) {
    variantsList = android.libraryVariants
} else if(android.hasProperty("testVariants")) {
    variantsList = android.testVariants
}
 
variantsList.all { variant ->

    def buildVariant = variant.variantData.getVariantConfiguration().getFullName().capitalize();
    def buildType = variant.buildType.name

    def mainLayoutDir = "$projectDir/src/main/res"
    def buildLayoutDir = "$projectDir/src/$buildType/res"
    def flavorLayoutDir = ""

    def variantBuildDir = "$variant.mergeResources.outputDir"
    def bundleBuildDirBase = ""
    def bundleBuildDir = "" 

    def packageTaskName = "package"+buildVariant+"Resources"
    if(tasks.hasProperty(packageTaskName)){
        bundleBuildDirBase = tasks[packageTaskName].outputDir
        bundleBuildDir = "$bundleBuildDirBase"
    }

    def inputDirs = [ mainLayoutDir, buildLayoutDir ]
    def flavor = ""
    def flavorRootDir = ""
    if(variant.variantData.getVariantConfiguration().hasFlavors()) {  
        flavor = variant.getVariantData().getVariantConfiguration().getFlavorName()
        flavorRootDir = "$projectDir/src/$flavor"
        flavorLayoutDir = "$projectDir/src/$flavor/res"
        inputDirs = [ mainLayoutDir, buildLayoutDir, flavorLayoutDir]
    }

    // get relevant xml files before merging
    def validXmlFiles = getValidXmlFiles(inputDirs)
    def styleFiles = getStyleFiles(inputDirs)

    //println validXmlFiles
    variant.outputs.each { output ->
        def includedXMLTags = ['text','hint','title','dialogTitle','summary','dialogMessage','negativeButtonText','positiveButtonText','summaryOff','summaryOn','switchTextOff','switchTextOn'/*,'contentDescription'*/]

        def taskNameMerge = "applangaMerge$buildVariant"
        final def task1 = task("$taskNameMerge"() << {
            description = 'Replaces String ID References with String ID values in all packaged Layout, Menu, Xml, Value files'
            
            // <!-- STYLE XML
            def FileTree variantBuildDirTreeStyles = fileTree(variantBuildDir){
                include 'values**/**/*.xml'
            }
            variantBuildDirTreeStyles.matching {
                include '*.xml'
            }

            def styleFilesBuildDir = [] as Set
            styleFilesBuildDir = variantBuildDirTreeStyles.getFiles()

            // get all strings which should be replaced
            def styleStringsToReplace = [] as Set
            styleFiles.each{ file -> 
                getStyleStrings(new XmlSlurper(false,false).parse(file.getAbsolutePath()), includedXMLTags).each{
                    styleStringsToReplace << it
                }
            }
                
            styleFilesBuildDir.each{ f ->
                def sXml = new XmlSlurper(false, false).parse(f)

                styleStringsToReplace.each{ s ->
                    replaceAtStringForStyle(sXml, includedXMLTags, s)
                }

                def sXmlFileString = groovy.xml.XmlUtil.serialize(sXml)
                f.delete()
                f.write(sXmlFileString, 'UTF-8') // style xml save to file
            }

            // STYLE XML -->

            def FileTree variantBuildDirTree = fileTree(variantBuildDir){
                include 'layout**/**/*.xml'
                include 'menu**/**/*.xml'
                include 'xml**/**/*.xml'
            }
            variantBuildDirTree.matching {
                include '*.xml'
            }

            def files = [] as Set
            files = variantBuildDirTree.getFiles()

            files.each { f ->
                def matching = false

                validXmlFiles.each { vf ->
                    if(vf.equals(f.getName())){
                        matching = true
                    }
                }

                if(matching){
                    def fXml = new XmlSlurper(false, false).parse(f)
                    fXml = replaceAtString(fXml, includedXMLTags)
                    
                    //println "modified file: " + f.getPath()
                    def xmlFileString = groovy.xml.XmlUtil.serialize(fXml)
                    f.delete()
                    f.write(xmlFileString, 'UTF-8')
                }
            }
        })

        def taskNameBundle = "applangaBundle$buildVariant"
        final def task2 = task("$taskNameBundle"() << {
            description = 'Replaces String ID References with String ID values in all packaged Layout, Menu, Xml, Value files'
            
            // <!-- STYLE XML
            def FileTree variantBuildDirTreeStyles = fileTree(variantBuildDir){
                include 'values**/**/*.xml'
            }
            variantBuildDirTreeStyles.matching {
                include '*.xml'
            }

            def styleFilesBuildDir = [] as Set
            styleFilesBuildDir = variantBuildDirTreeStyles.getFiles()

            // get all strings which should be replaced
            def styleStringsToReplace = [] as Set
            styleFiles.each{ file -> 
                getStyleStrings(new XmlSlurper(false,false).parse(file.getAbsolutePath()), includedXMLTags).each{
                    styleStringsToReplace << it
                }
            }
                
            styleFilesBuildDir.each{ f ->
                def sXml = new XmlSlurper(false, false).parse(f)

                styleStringsToReplace.each{ s ->
                    replaceAtStringForStyle(sXml, includedXMLTags, s)
                }

                def sXmlFileString = groovy.xml.XmlUtil.serialize(sXml)
                f.delete()
                f.write(sXmlFileString, 'UTF-8') // style xml save to file
            }

            // STYLE XML -->

            def FileTree variantBuildDirTree = fileTree(variantBuildDir){
                include 'layout**/**/*.xml'
                include 'menu**/**/*.xml'
                include 'xml**/**/*.xml'
            }
            variantBuildDirTree.matching {
                include '*.xml'
            }

            def files = [] as Set
            files = variantBuildDirTree.getFiles()

            files.each { f ->
                def matching = false

                validXmlFiles.each { vf ->
                    if(vf.equals(f.getName())){
                        matching = true
                    }
                }

                if(matching){
                    def fXml = new XmlSlurper(false, false).parse(f)
                    fXml = replaceAtString(fXml, includedXMLTags)
                    
                    //println "modified file: " + f.getPath()
                    def xmlFileString = groovy.xml.XmlUtil.serialize(fXml)
                    f.delete()
                    f.write(xmlFileString, 'UTF-8')
                }
            }
        })

        final def applangaParseIgnoredStrings = tasks.create(name: "applangaParseIgnoredStrings$buildVariant") << {
            def buildValues = new File("$variant.mergeResources.outputDir/values/values.xml")
            if(buildValues.exists()){
                def ignoredStrings = "";
                def parsedValuesXml = getValidXmlParser(buildValues) // to avoid encoding errors (mostly windows)

                parsedValuesXml.children().each{ element ->
                    if(element.name() == "string" || element.name() == "string-array" || element.name() == "plurals") {
                    //println element.@name
                    if(element.@translatable != null) {
                        println "translatable: "+ element.@translatable + " - Element: " + element.@name
                            if(element.@translatable == "false" || element.@translatable == false) {
                                //println "Name: " + element.name() + " String: " +  element.@name + ", translatable : " + element.@translatable
                                
                                def ignoreElement = element.@name
                                // if element contains "." we have to have two versions, the original and underscores instead of points
                                ignoreElement = ignoreElement.contains('.') ? ignoreElement.replaceAll('\\.','_') + "," + ignoreElement : ignoreElement;

                                ignoredStrings = ignoredStrings + ignoreElement + ","
                            }
                        }
                    }
                }

                File ignoredStringsFile = createFileSafe("$variant.mergeResources.outputDir/raw", "applanga_ignore.strings");
                ignoredStringsFile.write(ignoredStrings, 'UTF-8')

                /*
                if(tasks.hasProperty(packageTaskName))
                {
                    def rawFolderPack = new File("$bundleBuildDirBase/raw");
                    if(rawFolderPack.exists()) {
                        def ignoredStringsFilePack = new File("$bundleBuildDirBase/raw/applanga_ignore.strings");
                        ignoredStringsFilePack.createNewFile();
                        ignoredStringsFilePack.write(ignoredStrings)
                    }
                }*/
            }
        }

        final def applangaParseAllowedStrings = tasks.create(name: "applangaParseAllowedStrings$buildVariant") << {
            def allowedStrings = "";

            inputDirs.each { inputDir -> 
                def FileTree tree = fileTree(inputDir){
                    include "values**/**"
                }
                tree.matching{
                    include '*.xml'
                }

                tree.getFiles().each(){ f ->
                    def parsedValuesXml = getValidXmlParser(f) // to avoid encoding errors (mostly windows)

                    // parsedValuesXml instance of node
                    // parsedValuesXml.children() instance of list
                    parsedValuesXml.children().each { element ->
                        // element instance of Node
                        if(element instanceof groovy.util.Node){
                            if(element.name() == "string" || element.name() == "string-array" || element.name() == "plurals" ) {
                                def allowedElement = element.@name
                                def addToAllowedStrings = false
                                //avoiding duplicates
                                def alreadyExistingInAllowedStrings = false
                                allowedStrings.split(',').each{ value ->
                                    if(allowedElement.equals(value)){
                                        alreadyExistingInAllowedStrings = true
                                    }
                                }

                                if(element.@translatable != null) {
                                    //println "translatable: "+ element.@translatable + " - Element: " + element.@name
                                    if((element.@translatable == true) || (element.@translatable == "true")) {
                                        //println "Name: " + element.name() + " String: " +  element.@name + ", translatable : " + element.@translatable
                                        addToAllowedStrings = true
                                    }
                                } else {
                                    //println "translatable: false - Element: " + element.@name
                                    addToAllowedStrings = true
                                }
                                if(addToAllowedStrings && !alreadyExistingInAllowedStrings){
                                    //same as for ignored strings
                                    allowedElement = allowedElement.contains('.') ? allowedElement.replaceAll('\\.','_') + "," + allowedElement : allowedElement;

                                    allowedStrings = allowedStrings + allowedElement + ","
                                }
                            }
                        } else {
                            throw new GradleException("The resource file: $f is corrupt. $element is not a Node. Please contact Applanga for support.")
                        }
                    }
                }
            }

            def allowedStringsFile = createFileSafe("$variant.mergeResources.outputDir/raw","applanga_allow.strings");
            allowedStringsFile.write(allowedStrings, 'UTF-8')

        }

        final def applangaSetPackageName = tasks.create(name: "applangaSetPackageName$buildVariant") << {
            
            def originalPackageName = variant.getGenerateBuildConfig().buildConfigPackageName;

            [output.processManifest.manifestOutputFile,
             output.processManifest.instantRunManifestOutputFile
            ].forEach({ File manifestOutFile ->
                if (manifestOutFile.exists()) {
                    def mergedManifestParser = getValidXmlParser(manifestOutFile)
                    def packageNameNode = new Node(null, 'meta-data', ["android:name":'ApplangaResourcePackage', "android:value":"$originalPackageName"])
                    mergedManifestParser.find { element -> element.name() == 'application' }.children().add(packageNameNode)
                    def mergedManifestString = groovy.xml.XmlUtil.serialize(mergedManifestParser)
                    manifestOutFile.write(mergedManifestString, 'UTF-8')
                }
            })

        }
        applangaSetPackageName.dependsOn(output.processManifest)
        output.processManifest.finalizedBy(applangaSetPackageName)

        variant.mergeResources.finalizedBy(task1)

        if(tasks.hasProperty(packageTaskName))
        {
            tasks[packageTaskName].finalizedBy(task2)
        }

        task1.finalizedBy(applangaParseAllowedStrings);
        applangaParseAllowedStrings.finalizedBy(applangaParseIgnoredStrings);

        //applangaParseIgnoredStrings.mustRunAfter task1
        output.processResources.dependsOn applangaParseIgnoredStrings
        //applangaParseIgnoredStrings.dependsOn applangaParseAllowedStrings
    }
}

repositories {
    maven { url 'https://raw.github.com/applanga/sdk-android/master/maven/releases/' }
}